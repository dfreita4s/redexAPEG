#lang racket
(require redex)
(require "./peg.rkt")
(require "./judgments.rkt")
(require "./reduction.rkt")


;implementar o algoritmo do artigo do ford?
;usar o judgment wf para obter resultados imediatos
;receber uma gramatica e expressão para verificar se tá WF.
;função auxiliar - vamos precisar? 
;colocar numa lista qualquer as exp que a gnt acha que é bem formada
;final a lista é igual a 1 -> testar
;fazer uma meta funçao para verificar se uma gramatica é WF 
;(get-result (apply-reduction-relation* red (term (∅ ⊢ () (• 1 2) ↓ (1 3 3) () ⊥ (0)))

;fazer um extend-language e criar uma funçao que verifica as coisas?
;como colocar a gramatica
;lembrar dos testes que deram errado

#;(define (get-exp l)

    (if (eq? type "j")
        (list (list-ref (list-ref (car l) 2) 0))
        (list (list-ref (car l) 3))
        )
    )


#;(define (verf-seq exp)
    (if (eq? )

        )
    )

#;(define (is-WF exp);vai vir a expressao por exemplo (G (/ (/ 1 2) 2))

    ;  (define exp (get-exp e type))
    ; (print (car exp))
    (if (not (null? exp))
        (cond [(number? exp)                       #t]
              [(eq? (car exp) (term ε))                  #t]
              [(eq? (list-ref (car exp) 0) (term !))
               (is-WF (list-ref (car exp) 1))] ;NAO SEI PQ TA DANDO ERRADO NAO CONSIGO PEGAR O ! DA EXP
              [(eq? exp (term (G (* e_1))))         (verf-rep exp)]
              [(eq? exp (term (G (• e_1 e_2)))) #t] ;usar o judgment ⇀ pra testar se consome algo (judgment-hold ⇀ ∅ (• e_1 e_2)) 
              [(eq? (car exp) (term (G (/ e_1 e_2)))) (and (is-WF (term e_1)) (is-WF (term e_2)))]            
              [else "Deu errado"]
              )

        "null")
    )

(define (get-exp e)

  (if (eq? (list-ref (car e) 0) (term ∅))
      (list-ref (car e) 1)
      (car e))
      
  )

(define (verf-seq exp) ;VERIFICAR OQ CONSOME NA SEQUENCIA
  
  ;(print (judgment-holds (⇀ ∅ ,exp D) D))
  (if (eq? (judgment-holds (⇀ ∅ ,exp D) D) (list '(1 ⊥)))
      #t
      #f
      )
  )

(define (verf-rep exp) ;VERIFICAR OQ CONSOME NO REP
  ;(print (judgment-holds (⇀ ∅ ,exp D) D))
  (define result (judgment-holds (⇀ ∅ ,exp D) D))
  (if (eq? result '(⊥)) 
      #f
      #t
      )
  )

(define (is-WF e);vai vir a expressao por exemplo (G (/ (/ 1 2) 2))
  
  ;exp -> list
  (define exp (get-exp e))
  (define id (car exp))
  
  (print exp)
  (display " - ")
  
  (if (not (null? exp))
      (cond [(number? id)                             #t]
            [(eq? id (term ε))                        #t]
            [(eq? id (term !))                        (is-WF (list (list-ref exp 1)))]
            [(eq? id (term /))                        (and (is-WF (list (list (list-ref exp 1)))) (is-WF (list (list (list-ref exp 2)))))] 
            [(eq? id (term •))                        (or (is-WF (list (list (list-ref exp 1))))
                                                           (verf-seq   (list-ref exp 1))
                                                           (is-WF (list (list (list-ref exp 2)))))] ;usar o judgment ⇀ pra testar se consome algo (judgment-hold ⇀ ∅ (• e_1 e_2)) 
            [(eq? id (term *))                        (and (is-WF (list (list (list-ref exp 1))))
                                                           (verf-rep exp))]     
            [else "Deu errado"]
            )

      "null")
  )

#;(define-metafunction Reduct
    [(consome? e_1 e_1)     (judgment-holds (⇀ ∅ exp D) D)]
    [(consome? e_1 e_2)     #t]

    )

(is-WF (list '(∅ (1))))
(is-WF (list '(∅ (ε))))
(is-WF (list '(∅ (! (1)))))
(is-WF (list '(∅ (/ 1 2))))
(is-WF (list '(∅ (/ (/ 1 2) 2))))
(is-WF (list '(∅ (! (/ 1 2)))))
(is-WF (list '(∅ (• 1 2)))) ;--------------- NAO FUNCIONA
(is-WF (list '(∅ (* ε))))    ;---------------- NAO FUNCIONA 
